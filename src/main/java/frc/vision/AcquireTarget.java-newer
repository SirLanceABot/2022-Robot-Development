package frc.robot;

import java.util.ArrayList;
import java.util.List;

import edu.wpi.first.cameraserver.CameraServer;
import edu.wpi.first.cscore.UsbCamera;
import edu.wpi.first.cscore.VideoSource.ConnectionStrategy;
import edu.wpi.first.cscore.CvSink;
import edu.wpi.first.cscore.CvSource;

import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.MatOfPoint;
import org.opencv.core.MatOfPoint2f;
import org.opencv.core.Size;
import org.opencv.core.Point;
import org.opencv.core.Rect;
import org.opencv.core.RotatedRect;
import org.opencv.core.Scalar;
import org.opencv.imgproc.Imgproc;
import org.opencv.core.CvType;

public class AcquireTarget  implements Runnable
{
  // minimal acquire, add a rectangle to one, and display both streams adds about 8% cpu utilization
  // these are named streams 
  // Tell the CameraServer to send to the dashboard for debugging
  // Doubt camera will be streamed to humans during a match but if ti is
  // be sure to reduce the resolution

  static
  {
    System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
  }

  // set these 2 displays to false for match play to save Ethernet bandwidth
  // Probably put in config parameters such Constants class or SmartDashboard inputs
  boolean displayTargetCamera = true;
  boolean displayTargetContours = true;

	// This object is used to send the OpenCV processed image to the Dashboard if desired
	private CvSource outputStream;

	// This object is used to capture frames from the camera. The captured image is stored to a Mat
	private CvSink inputStream;

  GripPipeline gripPipeline = new GripPipeline();

  TargetDataB nextTargetData = new TargetDataB();

  public void run() {
    // The Registered Trademark looks right in VSC but it isn't "/dev/v4l/by-id/usb-Microsoft_MicrosoftÂ®_LifeCam_HD-3000-video-index0"
    UsbCamera TargetCamera = new UsbCamera("TargetCamera", "/dev/v4l/by-id/usb-Microsoft_Microsoft\u00AE_LifeCam_HD-3000-video-index0");
    TargetCamera.setConnectionStrategy(ConnectionStrategy.kKeepOpen);
    TargetCamera.setResolution(352, 288); // 10fps ok
    TargetCamera.setFPS(10);
    TargetCamera.setExposureManual(0);
 
    // Tell the CameraServer to send to the dashboard for debugging
    if(displayTargetCamera)
    {
      CameraServer.startAutomaticCapture(TargetCamera);
    }

    if(displayTargetContours)
    {
      outputStream = CameraServer.putVideo("TargetContours", 352, 288);
      outputStream.setFPS(7);
    }
 
    // Get a CvSink. This will capture Mats from the camera
    inputStream = new CvSink("TargetCvSink");
    inputStream.setSource(TargetCamera);

    // Mats are very memory expensive. Lets reuse this Mat.
    Mat mat = new Mat();

    // loop to grab camera image into a Mat, process the Mat, put an image to be viewed if desired

    // This cannot be 'true'. The program will never exit if it is. This lets
    // the robot stop this thread when restarting robot code or deploying.
    while (!Thread.interrupted())
    {
      // Tell the CvSink to grab a frame from the camera and put it
      // in the source mat.  If there is an error notify the output.
      if (inputStream.grabFrame(mat, 1.0) == 0) { // 1.0 second timeout; sometimes the 2nd acquire took longer then ok forever
        // Send the output the error
        System.out.println("intake camera error " + inputStream.getError());//intake camera error timed out getting frame
        // skip the rest of the current iteration
        continue;
      }

      /* YOUR IMAGE PROCESSING GOES HERE */
      // find the target
      // compute the angle to turn to align and the distance
      // send 4 pieces of data to whatever is driving this beast
      // angle to turn, distance to target, frame sequence number, time of acquisition

      // Demo OpenCV draw a rectangle on the image
      // Imgproc.rectangle(mat, new Point(10, 10), new Point(100, 100), new Scalar(255, 255, 255), 5);

      // END Demo OpenCV draw a rectangle on the image



/* demo GRIP pipeline */
      gripPipeline.process(mat); // filter the image with the GRIP pipeline

      // The gripPowerPortVisionPipeline creates an array of contours that must
      // be searched to find the target.
      ArrayList<MatOfPoint> filteredContours;
      filteredContours = new ArrayList<MatOfPoint>(gripPipeline.filterContoursOutput());

      
      int contourIndex = -1; // initialize here - using same value to indicate no contours and count contours
      int contourIndexBest = -1;

      // Check if no contours were found in the camera frame.
      if (filteredContours.isEmpty()) {
          // Display a message if no contours are found.
          Imgproc.putText(mat, "No Contours", new Point(20, 20), Imgproc.FONT_HERSHEY_SIMPLEX, 0.25,
                  new Scalar(255, 255, 255), 1);
          nextTargetData.portDistance = -1.;
          nextTargetData.angleToTurn = -1.;
          nextTargetData.isFreshData = true;
          nextTargetData.isTargetFound = false;
      } else {
          // contours were found
          if (filteredContours.size() > 1) { // not very good if more than one contour
              System.out.println(filteredContours.size() + " Contours found");
          }

          Rect boundRect = null; // upright rectangle

              // Draw all contours at once (negative index).
              // Positive thickness means not filled, negative thickness means filled.
              Imgproc.drawContours(mat, filteredContours, -1, new Scalar(255, 0, 0), 1);

          // Loop through all contours and just remember the best one

          for (MatOfPoint contour : filteredContours) {
              contourIndex++;

              // debug output Print all the contours

              // System.out.println("Contour Index = " + contourIndex);
              // System.out.println(contour.dump()); // OpenCV Mat dump one line string of numbers
              // or more control over formatting with your own array to manipulate
              // System.out.println(pId + " " + aContour.size() + " points in contour"); // a contour is a bunch of points
              // convert MatofPoint to an array of those Points and iterate (could do list of Points but no need for this)
              // for(Point aPoint : aContour.toArray())System.out.print(" " + aPoint); // print each point

              // for(int idx = 0; idx < contour.toArray().length; idx++)
              // {
              // System.out.println("(" + contour.toArray()[idx].x + ", " +
              // contour.toArray()[idx].y + ")");
              // }

              { // create angled bounding rectangle - could use angle to double check position
              RotatedRect rotatedRect;
              MatOfPoint2f NewMtx = new MatOfPoint2f(contour.toArray());
              rotatedRect = Imgproc.minAreaRect(NewMtx);
              NewMtx.release();
              Point[] boxPts = new Point[4];
              rotatedRect.points(boxPts);

              List<MatOfPoint> listMidContour = new ArrayList<MatOfPoint>();
              listMidContour.add(new MatOfPoint(boxPts[0], boxPts[1], boxPts[2], boxPts[3]));

              Imgproc.polylines(mat, // Matrix obj of the image
                  listMidContour, // java.util.List<MatOfPoint> pts
                  true, // isClosed
                  new Scalar(0, 255, 255), // Scalar object for color
                  1, // Thickness of the line
                  Imgproc.LINE_4 // line type
                  );
              
              Imgproc.putText(mat,
                  String.format("%4.0f", rotatedRect.angle),
                  boxPts[0],
                  Imgproc.FONT_HERSHEY_SIMPLEX, 0.3,
                  new Scalar(255, 255, 255), 1);

              while(!listMidContour.isEmpty()) {
                  listMidContour.get(0).release();
                  listMidContour.remove(0);
              }
              }

              // Create a bounding upright rectangle for the contour's points
              MatOfPoint2f NewMtx = new MatOfPoint2f(contour.toArray());
              boundRect = Imgproc.boundingRect(NewMtx);
              NewMtx.release();
              
              // Draw a Rect, using lines, that represents the Rect
              Point boxPts[] = new Point[4];
              boxPts[0] = boundRect.tl();
              boxPts[1] = new Point(boundRect.br().x, boundRect.tl().y);
              boxPts[2] = boundRect.br();
              boxPts[3] = new Point(boundRect.tl().x, boundRect.br().y);

              // draw edges of bounding rectangle
              List<MatOfPoint> listMidContour = new ArrayList<MatOfPoint>();
              listMidContour.add(new MatOfPoint(boxPts[0], boxPts[1], boxPts[2], boxPts[3]));

              Imgproc.polylines(mat, // Matrix obj of the image
                      listMidContour, // java.util.List<MatOfPoint> pts
                      true, // isClosed
                      new Scalar(0, 255, 255), // Scalar object for color
                      1, // Thickness of the line
                      Imgproc.LINE_4 // line type
                      );
            }
          } // end contours found
// end demo grip pipeline

        if(displayTargetContours)
        {
          outputStream.putFrame(mat); // Give the output stream a new image to display
        }
    

    }
  }
}
    
/* pscp  -v lvuser@roborio-4237-frc.local:/home/lvuser/camerid.txt  c:\\users\\rkt\\cameraid.txt*/
//MjpegServer server = CameraServer.startAutomaticCapture(TargetCamera); // save the server to enable changing quality, etc.
//System.out.println("targetcamera" + TargetCamera.getConfigJson());

// ["640x480 YUYV 30 fps","640x480 YUYV 20 fps","640x480 YUYV 15 fps","640x480 YUYV 10 fps","640x480 YUYV 7 fps","1280x720 YUYV 10 fps","1280x720 YUYV 7 fps","960x544 YUYV 15 fps","960x544 YUYV 10 fps","960x544 YUYV 7 fps","800x448 YUYV 20 fps","800x448 YUYV 15 fps","800x448 YUYV 10 fps","800x448 YUYV 7 fps","640x360 YUYV 30 fps","640x360 YUYV 20 fps","640x360 YUYV 15 fps","640x360 YUYV 10 fps","640x360 YUYV 7 fps","424x240 YUYV 30 fps","424x240 YUYV 20 fps","424x240 YUYV 15 fps","424x240 YUYV 10 fps","424x240 YUYV 7 fps","352x288 YUYV 30 fps","352x288 YUYV 20 fps","352x288 YUYV 15 fps","352x288 YUYV 10 fps","352x288 YUYV 7 fps","320x240 YUYV 30 fps","320x240 YUYV 20 fps","320x240 YUYV 15 fps","320x240 YUYV 10 fps","320x240 YUYV 7 fps","800x600 YUYV 15 fps","800x600 YUYV 10 fps","800x600 YUYV 7 fps","176x144 YUYV 30 fps","176x144 YUYV 20 fps","176x144 YUYV 15 fps","176x144 YUYV 10 fps","176x144 YUYV 7 fps","160x120 YUYV 30 fps","160x120 YUYV 20 fps","160x120 YUYV 15 fps","160x120 YUYV 10 fps","160x120 YUYV 7 fps","1280x800 YUYV 10 fps",
// "640x480 MJPEG 30 fps","640x480 MJPEG 20 fps","640x480 MJPEG 15 fps","640x480 MJPEG 10 fps","640x480 MJPEG 7 fps","1280x720 MJPEG 30 fps","1280x720 MJPEG 20 fps","1280x720 MJPEG 15 fps","1280x720 MJPEG 10 fps","1280x720 MJPEG 7 fps","960x544 MJPEG 30 fps","960x544 MJPEG 20 fps","960x544 MJPEG 15 fps","960x544 MJPEG 10 fps","960x544 MJPEG 7 fps","800x448 MJPEG 30 fps","800x448 MJPEG 20 fps","800x448 MJPEG 15 fps","800x448 MJPEG 10 fps","800x448 MJPEG 7 fps","640x360 MJPEG 30 fps","640x360 MJPEG 20 fps","640x360 MJPEG 15 fps","640x360 MJPEG 10 fps","640x360 MJPEG 7 fps","800x600 MJPEG 30 fps","800x600 MJPEG 20 fps","800x600 MJPEG 15 fps","800x600 MJPEG 10 fps","800x600 MJPEG 7 fps",
// "416x240 MJPEG 30 fps","416x240 MJPEG 20 fps","416x240 MJPEG 15 fps","416x240 MJPEG 10 fps","416x240 MJPEG 7 fps",
// "352x288 MJPEG 30 fps","352x288 MJPEG 20 fps","352x288 MJPEG 15 fps","352x288 MJPEG 10 fps","352x288 MJPEG 7 fps",
// "176x144 MJPEG 30 fps","176x144 MJPEG 20 fps","176x144 MJPEG 15 fps","176x144 MJPEG 10 fps","176x144 MJPEG 7 fps",
// "320x240 MJPEG 30 fps","320x240 MJPEG 20 fps","320x240 MJPEG 15 fps","320x240 MJPEG 10 fps","320x240 MJPEG 7 fps","160x120 MJPEG 30 fps","160x120 MJPEG 20 fps","160x120 MJPEG 15 fps","160x120 MJPEG 10 fps","160x120 MJPEG 7 fps"]